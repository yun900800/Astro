---
title: OpenClaw核心原理学习(三) —— 运行逻辑
description: 这是一篇关于OpenClaw如何运行的基础逻辑文章，不涉及具体的代码，而是将个人的理解记录下来
publishDate: 2026-02-24
tags:
  - OpenClaw
  - AI
  - 贪吃蛇
  - skill
ogImage: /social-card.avif
---
我首先提出一个问题，OpenClaw的底层是和Anthropic提出的MCP是一样的吗？

其实吧，要说一样吧，也类似；要说不一样吧，也有一些区别。

OpenClaw 的 "Skills"（技能） 系统在本质上确实与 Anthropic 提出的 MCP (Model Context Protocol) 非常相似，但它更强调本地执行。

**1. 它是如何像 MCP 一样工作的？**

在 OpenClaw 中，一个组件（Skill）通常就是一个包含 SKILL.md 指令说明和相关脚本（如 Python/Node.js）的文件夹。

**- 结构化暴露：** 每个 Skill 都会向大模型定义一套“工具集”。例如一个“文件操作组件”，会告诉模型它有 read_file、write_file、list_dir 这几个函数，并规定了参数格式（JSON Schema）。

**- 模型感知的工具：** 当你问“帮我查一下我的合同”，模型会检索可用的 Skill。如果找到了 RAG（检索增强生成）组件，它就会调用该组件的接口。

**2. 不同点：主动性与本地权限**

与标准的 MCP 相比，OpenClaw 的组件有更高的权限：

**- 本地网关：** OpenClaw 运行在你本地的 Node.js 网关上，它可以直接操作你的终端（Shell）、浏览器和文件系统，而不需要像传统 API 那样通过层层远程认证。

**- 长效性：** 它的组件可以被配置为“心跳触发”，比如每隔一小时检查一次邮件，这超出了简单“请求-响应”工具调用的范畴。

**2. 如何“开发”出一个贪吃蛇？底层逻辑是什么？**

**底层逻辑：三位一体的迭代循环**

**第一阶段：蓝图构建（Planning）**

当你下令“写一个贪吃蛇”时，OpenClaw 的第一个逻辑动作不是写代码，而是生成技术规范。

- 它会调用文件系统的 Skill，创建一个项目目录。

- 它会决定使用什么技术栈（例如 Python + Pygame 或 HTML5 Canvas）。

**第二阶段：原子化的代码编写（Implementation）**

大模型不能一次性写出 500 行完美代码。OpenClaw 会将其拆解为：

- **基础框架：** 先写出游戏主循环（Game Loop）。

- **原子功能：** 独立编写蛇的移动逻辑、食物生成逻辑、碰撞检测逻辑。

- **底层指令：** 此时模型使用的是 write_file 这种原子命令。

**第三阶段：执行、报错与视觉修正（The "Claw" Part）**

这是 OpenClaw 最强的地方。

- **本地执行：** 它会通过 shell_command 尝试运行游戏（如 python snake.py）。

- **错误捕获：** 如果运行报错，它会自动读取终端输出的报错信息（Traceback），然后针对性地修改代码再次尝试。

- **视觉确认（关键）：** 如果代码没报错但游戏不好玩（比如蛇走得太快），OpenClaw 可以利用截图功能捕获运行中的画面，通过 LMM（多模态大模型）分析截图：“蛇的颜色不对”或“屏幕太小了”，然后生成新的代码补丁。


**核心区别：工具人 vs 工程师传统开发OpenClaw**
 开发逻辑人类编写逻辑模型推理逻辑手动调试报错自动捕获终端输出并修复肉眼看 UI 是否正确截图回传大模型进行视觉验证


## 🛠️ OpenClaw 开发范式对比：工具人 vs 工程师

在 OpenClaw 的底层逻辑中，传统的“脚本执行”被升级为了“智能体闭环”。以下是两种模式在处理复杂任务（如开发一个游戏）时的本质区别：

| 维度 | 传统自动化 (工具人模式) | OpenClaw (工程师模式) |
| :--- | :--- | :--- |
| **逻辑起点** | **指令驱动**：接收预定义的 If-Then 命令 | **目标驱动**：接收自然语言目标（如“写个贪吃蛇”） |
| **错误处理** | **脆弱中断**：代码一旦报错或 UI 变动立即跳出 | **自愈闭环**：通过读取终端 Traceback 自动修改代码并重跑 |
| **视觉能力** | **盲人摸象**：只能通过 DOM 树或固定像素坐标判断 | **语义感知**：通过 LMM 像人一样“看”运行效果是否符合预期 |
| **代码生成** | **静态输出**：一次性生成代码，对错听天由命 | **迭代进化**：采用 **Write -> Run -> Fix** 的递归逻辑 |
| **运行环境** | **沙盒隔离**：通常只能在受限的 IDE 或环境运行 | **全权限接管**：直接调用 Shell、文件系统和多模态接口 |

---

### 🧠 核心差异深度拆解

#### 1. 闭环控制（The Feedback Loop）
* **工具人：** 只是一个翻译官。你给它 $A$，它产出 $B$。
* **工程师：** 是一个控制系统。它产出 $B$ 后，会通过 **Observe** 观察 $B$ 的结果，如果发现 $B \neq Target$，它会重新思考并产生 $B'$。

#### 2. 环境感知（Environmental Context）
* **工具人：** 像是在黑暗中搬砖，不关心砖头搬到了哪里。
* **工程师：** 拥有“视觉反馈”和“终端反馈”。它能意识到“游戏窗口弹出来了”或者“现在的蛇移动太快了，我需要调整帧率”。

#### 3. 技能原子化（Atomic Skills）
* **工具人：** 每次都要重写逻辑。
* **工程师：** 将常用操作（如写文件、截图、搜 Google）封装为 **Skills**。在开发任务时，它会像调用大脑中的“肌肉记忆”一样调用这些工具。
